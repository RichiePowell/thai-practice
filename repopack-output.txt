This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-26T05:40:46.536Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
public/
  favicon.svg
src/
  app/
    globals.css
    layout.tsx
    page.tsx
  components/
    game/
      AudioPreloader.tsx
      AudioToggle.tsx
      CategorySelector.tsx
      GameHeader.tsx
      GameScreen.tsx
      MainMenu.tsx
      SettingsPanel.tsx
      ThaiCharacterDisplay.tsx
      ThaiPhraseGame.tsx
      ThemeToggle.tsx
    ui/
      alert.tsx
      badge.tsx
      button.tsx
      card.tsx
      collapsible.tsx
      label.tsx
      logo.tsx
      progress.tsx
      slider.tsx
      switch.tsx
    ThemeScript.tsx
  constants/
    content/
      classifiers.ts
      colors.ts
      commonPhrases.ts
      directions.ts
      familyAndRelationships.ts
      foodAndDrink.ts
      index.ts
      numbers.ts
      pronouns.ts
      questionWords.ts
      thaiScript.ts
      thaiScriptAdvanced.ts
      thaiScriptIntermediate.ts
      timeAndCalendar.ts
      travel.ts
    categories.ts
    config.ts
    phrases.ts
    settings.ts
  context/
    AudioContext.tsx
    ThemeContext.tsx
  hooks/
    useGameLogic.ts
  lib/
    utils.ts
  types/
    ContentTypes.ts
    FeedbackType.ts
    GameSettings.ts
    LearningCategory.ts
    ThaiPhrase.ts
    WrongAnswerType.ts
.eslintrc.json
.gitignore
components.json
next.config.ts
package.json
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: public/favicon.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <defs>
    <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#4F46E5;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#7C3AED;stop-opacity:1" />
    </linearGradient>
  </defs>
  
  <!-- Background circle -->
  <circle cx="16" cy="16" r="15" fill="url(#grad)" />
  
  <!-- Thai character ก (first consonant of Thai alphabet) -->
  <text x="16" y="22" 
    font-family="Arial" 
    font-size="20" 
    fill="white" 
    text-anchor="middle" 
    font-weight="bold">
    ก
  </text>
</svg>

================
File: src/app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    /* Thai flag blue for primary elements */
    --primary: 222 47% 31%;
    --primary-foreground: 0 0% 100%;

    /* Thai red */
    --destructive: 0 72% 51%;
    --destructive-foreground: 0 0% 100%;

    /* Gold accents */
    --accent: 45 93% 47%;
    --accent-foreground: 0 0% 0%;

    /* Clean background and normal text color */
    --background: 40 33% 96%;
    --foreground: 220 10% 20%;

    /* Card styling */
    --card: 0 0% 100%;
    --card-foreground: 220 10% 20%;

    /* Popover/dropdown styling */
    --popover: 0 0% 100%;
    --popover-foreground: 220 10% 20%;

    /* Secondary elements */
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 220 10% 20%;

    /* Muted elements */
    --muted: 210 40% 96.1%;
    --muted-foreground: 220 10% 45%;

    /* Form elements */
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222 47% 31%;

    --radius: 0.5rem;
  }

  .dark {
    /* Dark theme background and normal text */
    --background: 215 50% 8%;
    --foreground: 210 20% 98%;

    /* Card backgrounds slightly lighter than main background */
    --card: 215 50% 12%;
    --card-foreground: 210 20% 98%;

    /* Popover matches card */
    --popover: 215 50% 12%;
    --popover-foreground: 210 20% 98%;

    /* Brighter primary for dark mode */
    --primary: 215 80% 70%;
    --primary-foreground: 215 50% 8%;

    /* Secondary with better contrast */
    --secondary: 215 50% 20%;
    --secondary-foreground: 210 20% 98%;

    /* Much lighter muted colors */
    --muted: 215 50% 20%;
    --muted-foreground: 210 40% 90%;

    /* Brighter accent */
    --accent: 45 70% 65%;
    --accent-foreground: 215 50% 8%;

    /* Brighter destructive */
    --destructive: 0 62% 65%;
    --destructive-foreground: 210 20% 98%;

    /* More visible borders */
    --border: 215 50% 25%;
    --input: 215 50% 25%;
    --ring: 45 70% 65%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@import url("https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@400;500;700&display=swap");

.font-thai {
  font-family: "Noto Sans Thai", system-ui, sans-serif;
}

================
File: src/app/layout.tsx
================
// app/layout.tsx
import type { Metadata } from "next";
import { AudioProvider } from "@/context/AudioContext";
import { ThemeProvider } from "@/context/ThemeContext";
import { AudioToggle } from "@/components/game/AudioToggle";
import { ThemeToggle } from "@/components/game/ThemeToggle";
import { ThemeScript } from "@/components/ThemeScript";
import "./globals.css";
import { ReactNode } from "react";

export const metadata: Metadata = {
  title: "Thai Language Game",
  description: "Learn Thai phrases through an interactive quiz!",
  icons: {
    icon: [
      {
        url: "/favicon.svg",
        type: "image/svg+xml",
      },
    ],
  },
};

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head />
      <body className="min-h-screen bg-background">
        <ThemeScript />
        <ThemeProvider>
          <AudioProvider>
            <div className="relative">
              <ThemeToggle />
              <AudioToggle />
              {children}
            </div>
          </AudioProvider>
        </ThemeProvider>
      </body>
    </html>
  );
}

================
File: src/app/page.tsx
================
import { ThaiPhraseGame } from "@/components/game/ThaiPhraseGame";

export default function Home() {
  return (
    <main className="container mx-auto p-4 min-h-screen flex items-center justify-center">
      <ThaiPhraseGame />
    </main>
  );
}

================
File: src/components/game/AudioPreloader.tsx
================
import React, { useEffect, useRef } from "react";

const AudioPreloader = () => {
  const successAudioRef = useRef<HTMLAudioElement | null>(null);
  const errorAudioRef = useRef<HTMLAudioElement | null>(null);

  useEffect(() => {
    // Create and preload success sound
    successAudioRef.current = new Audio("/sounds/success.mp3");
    successAudioRef.current.load();
    successAudioRef.current.preload = "auto";

    // Create and preload error sound
    errorAudioRef.current = new Audio("/sounds/error.mp3");
    errorAudioRef.current.load();
    errorAudioRef.current.preload = "auto";

    // Cleanup function
    return () => {
      if (successAudioRef.current) {
        successAudioRef.current = null;
      }
      if (errorAudioRef.current) {
        errorAudioRef.current = null;
      }
    };
  }, []);

  return null;
};

export default AudioPreloader;

================
File: src/components/game/AudioToggle.tsx
================
"use client";

import { Volume2, VolumeX } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useAudio } from "@/context/AudioContext";

export const AudioToggle = () => {
  const { isSoundEnabled, toggleSound } = useAudio();

  return (
    <Button
      variant="ghost"
      size="icon"
      onClick={toggleSound}
      className="fixed top-4 right-4 rounded-full"
      title={isSoundEnabled ? "Mute Sound" : "Enable Sound"}
    >
      {isSoundEnabled ? (
        <Volume2 className="w-5 h-5" />
      ) : (
        <VolumeX className="w-5 h-5" />
      )}
    </Button>
  );
};

================
File: src/components/game/CategorySelector.tsx
================
"use client";

import React, { useState, useMemo } from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  GraduationCap,
  MessageSquare,
  Hash,
  UtensilsCrossed,
  BookOpen,
  Plane,
  Map,
  User,
  LayoutGrid,
  BookText,
  Clock,
  Users2,
  Palette,
  HelpCircle,
  SortAsc,
  Filter,
} from "lucide-react";
import type { LearningCategory } from "@/types/LearningCategory";
import { LEARNING_CATEGORIES } from "@/constants/categories";
import { getCategoryItemCount } from "@/constants/content";

const iconMap = {
  GraduationCap,
  MessageSquare,
  Hash,
  UtensilsCrossed,
  BookOpen,
  Plane,
  Map,
  User,
  LayoutGrid,
  BookText,
  Clock,
  Users2,
  Palette,
  HelpCircle,
} as const;

type Difficulty = "all" | "beginner" | "intermediate" | "advanced";
type SortOption = "default" | "alphabetical" | "items";

interface CategorySelectorProps {
  onSelect: (category: LearningCategory) => void;
}

const difficultyColors = {
  beginner:
    "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-100 border-green-200 dark:border-green-800",
  intermediate:
    "bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-100 border-blue-200 dark:border-blue-800",
  advanced:
    "bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-100 border-purple-200 dark:border-purple-800",
};

export const CategorySelector: React.FC<CategorySelectorProps> = ({
  onSelect,
}) => {
  const [difficulty, setDifficulty] = useState<Difficulty>("all");
  const [sortOption, setSortOption] = useState<SortOption>("default");

  const filteredAndSortedCategories = useMemo(() => {
    let categories = [...LEARNING_CATEGORIES];

    // Filter by difficulty
    if (difficulty !== "all") {
      categories = categories.filter(
        (category) => category.difficulty === difficulty
      );
    }

    // Sort categories
    switch (sortOption) {
      case "alphabetical":
        return categories.sort((a, b) => a.title.localeCompare(b.title));
      case "items":
        return categories.sort(
          (a, b) => getCategoryItemCount(b.id) - getCategoryItemCount(a.id)
        );
      default:
        return categories;
    }
  }, [difficulty, sortOption]);

  if (LEARNING_CATEGORIES.length === 0) {
    return (
      <div className="text-center p-8">
        <h2 className="text-2xl font-bold text-primary mb-4">Coming Soon!</h2>
        <p className="text-muted-foreground">
          We&apos;re working on adding learning content.
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="text-center">
        <h2 className="text-2xl font-bold text-primary mb-2">
          Choose a Category
        </h2>
        <p className="text-muted-foreground">
          Select what you&apos;d like to learn today
        </p>
      </div>

      <div className="flex flex-wrap gap-2 justify-center">
        {/* Difficulty filters */}
        <div className="flex gap-2 items-center">
          <Filter className="w-4 h-4" />
          <Button
            variant={difficulty === "all" ? "default" : "outline"}
            size="sm"
            onClick={() => setDifficulty("all")}
          >
            All
          </Button>
          <Button
            variant={difficulty === "beginner" ? "default" : "outline"}
            size="sm"
            className={difficulty === "beginner" ? "bg-green-600" : ""}
            onClick={() => setDifficulty("beginner")}
          >
            Beginner
          </Button>
          <Button
            variant={difficulty === "intermediate" ? "default" : "outline"}
            size="sm"
            className={difficulty === "intermediate" ? "bg-blue-600" : ""}
            onClick={() => setDifficulty("intermediate")}
          >
            Intermediate
          </Button>
          <Button
            variant={difficulty === "advanced" ? "default" : "outline"}
            size="sm"
            className={difficulty === "advanced" ? "bg-purple-600" : ""}
            onClick={() => setDifficulty("advanced")}
          >
            Advanced
          </Button>
        </div>

        {/* Sort options */}
        <div className="flex gap-2 items-center ml-4">
          <SortAsc className="w-4 h-4" />
          <Button
            variant={sortOption === "default" ? "default" : "outline"}
            size="sm"
            onClick={() => setSortOption("default")}
          >
            Default
          </Button>
          <Button
            variant={sortOption === "alphabetical" ? "default" : "outline"}
            size="sm"
            onClick={() => setSortOption("alphabetical")}
          >
            A-Z
          </Button>
          <Button
            variant={sortOption === "items" ? "default" : "outline"}
            size="sm"
            onClick={() => setSortOption("items")}
          >
            Most Items
          </Button>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {filteredAndSortedCategories.map((category) => {
          const Icon = iconMap[category.icon as keyof typeof iconMap];
          const itemCount = getCategoryItemCount(category.id);

          return (
            <Card
              key={category.id}
              className="p-4 cursor-pointer hover:shadow-lg transition-all duration-300 hover:-translate-y-1 border border-border hover:border-primary bg-card"
              onClick={() => onSelect(category)}
            >
              <div className="flex items-start gap-4">
                <div className="rounded-lg bg-primary/10 p-2">
                  {Icon && <Icon className="w-6 h-6 text-primary" />}
                </div>
                <div className="flex-1">
                  <div className="flex items-center justify-between mb-2">
                    <h3 className="font-semibold text-lg text-foreground">
                      {category.title}
                    </h3>
                    <Badge
                      variant="secondary"
                      className={difficultyColors[category.difficulty]}
                    >
                      {category.difficulty}
                    </Badge>
                  </div>
                  <p className="text-sm text-muted-foreground mb-2">
                    {category.description}
                  </p>
                  <div className="text-xs text-muted-foreground/80">
                    {itemCount} items
                  </div>
                </div>
              </div>
            </Card>
          );
        })}
      </div>
    </div>
  );
};

================
File: src/components/game/GameHeader.tsx
================
import React from "react";
import { Timer, Trophy } from "lucide-react";
import { Progress } from "@/components/ui/progress";

interface GameHeaderProps {
  score: number;
  totalQuestions: number;
  questionsPerRound: number;
  timeLeft?: number;
  timerEnabled?: boolean;
  onReturnToMenu: () => void;
}

const GameHeader: React.FC<GameHeaderProps> = ({
  score,
  totalQuestions,
  questionsPerRound,
  timeLeft,
  timerEnabled,
}) => {
  const progressPercentage = (totalQuestions / questionsPerRound) * 100;

  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4 ml-auto">
          <div className="flex items-center gap-1.5">
            <Trophy className="w-4 h-4 text-yellow-500" />
            <span className="text-sm font-medium">
              {score}/{totalQuestions}
            </span>
          </div>

          {timerEnabled && typeof timeLeft === "number" && (
            <div className="flex items-center gap-1.5">
              <Timer className="w-4 h-4" />
              <span
                className={`font-mono text-sm font-medium ${
                  timeLeft <= 3 ? "text-red-500" : ""
                }`}
              >
                {timeLeft}s
              </span>
            </div>
          )}
        </div>
      </div>

      <div className="flex items-center gap-2">
        <Progress value={progressPercentage} className="h-1.5 flex-1" />
        <span className="text-xs text-gray-500 min-w-[3rem] text-right">
          {totalQuestions + 1}/{questionsPerRound}
        </span>
      </div>
    </div>
  );
};

export default GameHeader;

================
File: src/components/game/GameScreen.tsx
================
"use client";

import React, { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { X } from "lucide-react";
import type { GameSettings } from "@/types/GameSettings";
import type { LearningCategory } from "@/types/LearningCategory";
import useGameLogic from "@/hooks/useGameLogic";
import ThaiCharacterDisplay from "./ThaiCharacterDisplay";
import GameHeader from "./GameHeader";
import { WrongAnswer } from "@/types/WrongAnswerType";
import { useAudio } from "@/context/AudioContext";

interface GameScreenProps {
  settings: GameSettings;
  category: LearningCategory;
  onGameOver: (score: number, wrongAnswers: WrongAnswer[]) => void;
  onReturnToMenu: () => void;
}

export const GameScreen: React.FC<GameScreenProps> = ({
  settings,
  category,
  onGameOver,
  onReturnToMenu,
}) => {
  const [isPlaying, setIsPlaying] = useState(false);
  const { isSoundEnabled } = useAudio();

  const {
    currentItem,
    options,
    score,
    totalQuestions,
    feedback,
    timeLeft,
    canProceed,
    handleAnswer,
    handleNextQuestion,
  } = useGameLogic({
    settings,
    onGameOver,
    category,
  });

  const speak = (text: string, isManualPlay: boolean = false) => {
    // Only check sound enabled for auto-play, not manual play
    if (!isManualPlay && !isSoundEnabled) return;

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = "th-TH";
    setIsPlaying(true);

    utterance.onend = () => {
      setIsPlaying(false);
    };

    utterance.onerror = () => {
      setIsPlaying(false);
    };

    // Cancel any ongoing speech
    speechSynthesis.cancel();
    speechSynthesis.speak(utterance);
  };

  // Auto speak when question changes
  useEffect(() => {
    if (settings.autoSpeak && currentItem && !feedback) {
      speak(currentItem.thai); // Auto-play respects sound enabled setting
    }
  }, [currentItem, settings.autoSpeak, feedback]);

  return (
    <div className="space-y-6">
      <GameHeader
        score={score}
        totalQuestions={totalQuestions}
        questionsPerRound={settings.questionsPerRound}
        timeLeft={timeLeft}
        timerEnabled={settings.timerEnabled}
        onReturnToMenu={onReturnToMenu}
      />

      {currentItem && (
        <div className="space-y-6">
          <div className="text-center">
            <ThaiCharacterDisplay
              character={currentItem.thai}
              size="text-5xl"
              className={`transition-all duration-300 ${
                feedback?.correct ? "text-green-500 dark:text-green-400" : ""
              }`}
              onManualSpeak={() => speak(currentItem.thai, true)} // Manual play ignores sound enabled setting
              isPlaying={isPlaying}
            />

            {settings.showRomanized && (
              <div className="text-lg text-muted-foreground mt-2">
                {currentItem.romanized}
              </div>
            )}
          </div>

          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            {options.map((option, index) => (
              <Button
                key={index}
                onClick={() => handleAnswer(option)}
                className={`p-4 h-auto text-left transition-all duration-300
                  border-2 dark:border-primary/30
                  hover:border-primary dark:hover:border-primary
                  hover:bg-primary/10 dark:hover:bg-primary/20
                  hover:text-foreground dark:hover:text-foreground
                  disabled:opacity-100
                  ${
                    feedback?.correct && option.id === currentItem.id
                      ? "bg-green-500 hover:bg-green-600 dark:bg-green-600 dark:hover:bg-green-700 text-white dark:text-white scale-105 border-green-400 dark:border-green-500 disabled:text-white dark:disabled:text-white"
                      : "bg-card dark:text-white disabled:opacity-50"
                  }`}
                variant="outline"
                disabled={!!feedback}
              >
                <span className="font-bold">{option.meaning}</span>
              </Button>
            ))}
          </div>

          {feedback && !feedback.correct && (
            <div className="space-y-4">
              <div className="p-4 rounded-lg text-center bg-red-100/90 dark:bg-red-900/50 text-red-800 dark:text-red-200">
                <div className="flex items-center justify-center gap-2">
                  <X className="w-5 h-5" />
                  <span>
                    <span>{feedback.message}</span>{" "}
                    {feedback.answer && (
                      <span className="font-bold">{feedback.answer}</span>
                    )}
                  </span>
                </div>
              </div>

              {canProceed && (
                <Button
                  onClick={handleNextQuestion}
                  className="w-full bg-primary hover:bg-primary/90"
                >
                  Continue to Next Question
                </Button>
              )}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default GameScreen;

================
File: src/components/game/MainMenu.tsx
================
"use client";

import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Play, Settings } from "lucide-react";
import { SettingsPanel } from "./SettingsPanel";
import type { GameSettings } from "@/types/GameSettings";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";

interface MainMenuProps {
  onStartGame: () => void;
  settings: GameSettings;
  onSettingsChange: (settings: GameSettings) => void;
}

export const MainMenu: React.FC<MainMenuProps> = ({
  onStartGame,
  settings,
  onSettingsChange,
}) => {
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);

  return (
    <div className="space-y-8">
      <div className="text-center">
        <h1 className="text-4xl font-bold mb-4 text-foreground">
          Thai Language Game
        </h1>
        <p className="text-muted-foreground">
          Learn Thai phrases through an interactive quiz!
        </p>
      </div>

      <Button
        onClick={onStartGame}
        className="w-full py-8 text-xl bg-primary hover:bg-primary/90 text-primary-foreground"
      >
        <Play className="w-6 h-6 mr-2" />
        Start Game
      </Button>

      <Collapsible open={isSettingsOpen} onOpenChange={setIsSettingsOpen}>
        <div className="bg-card rounded-lg border">
          <CollapsibleTrigger asChild>
            <Button
              variant="ghost"
              className="w-full flex items-center justify-between p-6 hover:bg-accent hover:text-accent-foreground"
            >
              <div className="flex items-center">
                <Settings className="w-5 h-5 mr-2" />
                <h2 className="text-lg">Game Settings</h2>
              </div>
              <span className="text-sm text-muted-foreground">
                {isSettingsOpen ? "Hide Settings" : "Show Settings"}
              </span>
            </Button>
          </CollapsibleTrigger>
          <CollapsibleContent>
            <div className="p-6 border-t">
              <SettingsPanel
                settings={settings}
                onSettingsChange={onSettingsChange}
              />
            </div>
          </CollapsibleContent>
        </div>
      </Collapsible>
    </div>
  );
};

================
File: src/components/game/SettingsPanel.tsx
================
"use client";

import React from "react";
import { Slider } from "@/components/ui/slider";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import type { GameSettings } from "@/types/GameSettings";
import { GAME_CONFIG } from "@/constants/config";

interface SettingsPanelProps {
  settings: GameSettings;
  onSettingsChange: (settings: GameSettings) => void;
}

export const SettingsPanel: React.FC<SettingsPanelProps> = ({
  settings,
  onSettingsChange,
}) => {
  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <Label htmlFor="timer-toggle" className="text-foreground">
          Enable Timer
        </Label>
        <Switch
          id="timer-toggle"
          checked={settings.timerEnabled}
          onCheckedChange={(checked) =>
            onSettingsChange({ ...settings, timerEnabled: checked })
          }
        />
      </div>

      <div className="space-y-2">
        <Label className="text-foreground">Timer Duration (seconds)</Label>
        <Slider
          disabled={!settings.timerEnabled}
          min={GAME_CONFIG.MIN_TIMER_DURATION}
          max={GAME_CONFIG.MAX_TIMER_DURATION}
          step={GAME_CONFIG.TIMER_STEP}
          value={[settings.timerDuration]}
          onValueChange={([value]) =>
            onSettingsChange({ ...settings, timerDuration: value })
          }
          className="[&>[role=slider]]:bg-primary [&>[role=slider]]:border-primary"
        />
        <div className="text-right text-sm text-muted-foreground">
          {settings.timerDuration} seconds
        </div>
      </div>

      <div className="flex items-center justify-between">
        <Label htmlFor="romanized-toggle" className="text-foreground">
          Show Romanized Text
        </Label>
        <Switch
          id="romanized-toggle"
          checked={settings.showRomanized}
          onCheckedChange={(checked) =>
            onSettingsChange({ ...settings, showRomanized: checked })
          }
        />
      </div>

      <div className="flex items-center justify-between">
        <Label htmlFor="auto-speak-toggle" className="text-foreground">
          Auto-Play Thai Pronunciation
        </Label>
        <Switch
          id="auto-speak-toggle"
          checked={settings.autoSpeak}
          onCheckedChange={(checked) =>
            onSettingsChange({ ...settings, autoSpeak: checked })
          }
        />
      </div>

      <div className="space-y-2">
        <Label className="text-foreground">Questions per Round</Label>
        <Slider
          min={GAME_CONFIG.MIN_QUESTIONS}
          max={GAME_CONFIG.MAX_QUESTIONS}
          step={GAME_CONFIG.QUESTIONS_STEP}
          value={[settings.questionsPerRound]}
          onValueChange={([value]) =>
            onSettingsChange({ ...settings, questionsPerRound: value })
          }
          className="[&>[role=slider]]:bg-primary [&>[role=slider]]:border-primary"
        />
        <div className="text-right text-sm text-muted-foreground">
          {settings.questionsPerRound} questions
        </div>
      </div>
    </div>
  );
};

export default SettingsPanel;

================
File: src/components/game/ThaiCharacterDisplay.tsx
================
import React, { useState, useEffect } from "react";
import { AlertCircle, Volume2 } from "lucide-react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";

interface ThaiCharacterDisplayProps {
  character: string;
  size?: string;
  showFallback?: boolean;
  className?: string;
  onManualSpeak?: (text: string) => void; // Renamed from onSpeak to onManualSpeak
  isPlaying?: boolean;
}

const ThaiCharacterDisplay: React.FC<ThaiCharacterDisplayProps> = ({
  character,
  size = "text-4xl",
  showFallback = true,
  className = "",
  onManualSpeak,
  isPlaying = false,
}) => {
  const [isLoaded, setIsLoaded] = useState<boolean>(false);
  const [hasError, setHasError] = useState<boolean>(false);

  useEffect(() => {
    // Create a canvas to test if the character can be rendered
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    if (context) {
      context.font = "16px Noto Sans Thai, Arial, sans-serif";
      const metrics = context.measureText(character);

      // Check if the character is rendered as a box or missing glyph
      setHasError(
        metrics.width === 0 || metrics.width === context.measureText("□").width
      );
    }
    setIsLoaded(true);
  }, [character]);

  if (!isLoaded) {
    return (
      <div className={`animate-pulse bg-gray-200 ${size} rounded`}>&nbsp;</div>
    );
  }

  if (hasError && showFallback) {
    return (
      <Alert variant="destructive" className="my-2">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>Display Error</AlertTitle>
        <AlertDescription className="text-sm">
          The Thai character &ldquo;{character}&ldquo; (
          {character.codePointAt(0)?.toString(16)}) could not be rendered.
          Please ensure you have Thai fonts installed.
        </AlertDescription>
      </Alert>
    );
  }

  return (
    <div className="relative inline-flex items-center group">
      <div
        className={`font-thai transition-all duration-300 ${size} ${className}`}
      >
        {character}
      </div>
      {onManualSpeak && (
        <Button
          variant="ghost"
          size="icon"
          onClick={() => onManualSpeak(character)}
          className={`h-6 w-6 absolute -right-7 top-1/2 -translate-y-1/2 text-gray-500 hover:text-primary transition-colors ${
            isPlaying ? "text-primary" : ""
          }`}
        >
          <Volume2 className={`h-3 w-3 ${isPlaying ? "animate-pulse" : ""}`} />
        </Button>
      )}
    </div>
  );
};

export default ThaiCharacterDisplay;

================
File: src/components/game/ThaiPhraseGame.tsx
================
"use client";

import React, { useCallback, useState } from "react";
import { Card, CardHeader, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { RefreshCw, Trophy, Volume2, X, Home } from "lucide-react";
import { MainMenu } from "./MainMenu";
import { GameScreen } from "./GameScreen";
import type { GameSettings } from "@/types/GameSettings";
import { DEFAULT_SETTINGS } from "@/constants/settings";
import { Logo } from "../ui/logo";
import { LearningCategory } from "@/types/LearningCategory";
import { CategorySelector } from "./CategorySelector";
import { ContentItem } from "@/types/ContentTypes";
import ThaiCharacterDisplay from "./ThaiCharacterDisplay";
import { useAudio } from "@/context/AudioContext";

type GameState = "menu" | "category-select" | "playing" | "gameOver";

interface WrongAnswer {
  question: ContentItem;
  playerAnswer: ContentItem;
}

export const ThaiPhraseGame = () => {
  const [gameState, setGameState] = useState<GameState>("menu");
  const [settings, setSettings] = useState<GameSettings>(DEFAULT_SETTINGS);
  const [finalScore, setFinalScore] = useState(0);
  const [wrongAnswers, setWrongAnswers] = useState<WrongAnswer[]>([]);
  const [selectedCategory, setSelectedCategory] =
    useState<LearningCategory | null>(null);
  const { playSound } = useAudio();

  const handleGameOver = useCallback(
    (score: number, wrongAnswers: WrongAnswer[]) => {
      // Calculate percentage
      const percentage = (score / settings.questionsPerRound) * 100;

      // Play appropriate sound based on performance
      if (percentage >= 80) {
        playSound("complete");
      } else if (percentage <= 40) {
        playSound("failure");
      }

      const uniqueWrongAnswers = wrongAnswers.filter(
        (answer, index, self) =>
          index === self.findIndex((a) => a.question.id === answer.question.id)
      );

      setFinalScore(score);
      setWrongAnswers(uniqueWrongAnswers);
      setGameState("gameOver");
    },
    [settings.questionsPerRound, playSound]
  );

  const speak = (text: string) => {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = "th-TH";
    speechSynthesis.speak(utterance);
  };

  const handleReturnToMenu = () => {
    setGameState("menu");
    setWrongAnswers([]);
  };

  const HomeButton = () => (
    <Button
      variant="ghost"
      size="icon"
      onClick={handleReturnToMenu}
      className="absolute top-4 left-4 h-8 w-8 rounded-full"
      title="Return to Menu"
    >
      <Home className="h-8 w-8" />
    </Button>
  );

  return (
    <Card className="w-full max-w-2xl mx-auto shadow-lg relative">
      {gameState !== "menu" && <HomeButton />}
      {gameState !== "playing" && gameState !== "gameOver" && (
        <CardHeader>
          <Logo />
        </CardHeader>
      )}
      <CardContent className={gameState === "playing" ? "pt-6" : ""}>
        {gameState === "menu" && (
          <MainMenu
            onStartGame={() => setGameState("category-select")}
            settings={settings}
            onSettingsChange={setSettings}
          />
        )}

        {gameState === "category-select" && (
          <CategorySelector
            onSelect={(category) => {
              setSelectedCategory(category);
              setGameState("playing");
            }}
          />
        )}

        {gameState === "playing" && selectedCategory && (
          <GameScreen
            settings={settings}
            category={selectedCategory}
            onGameOver={handleGameOver}
            onReturnToMenu={handleReturnToMenu}
          />
        )}

        {gameState === "gameOver" && (
          <div className="space-y-6 pt-6">
            <div className="text-center space-y-4">
              <Trophy className="w-16 h-16 mx-auto text-yellow-500 dark:text-yellow-400" />
              <p className="text-xl font-bold text-foreground">Game Over!</p>
              <p className="text-lg text-foreground">
                Final Score: {finalScore}/{settings.questionsPerRound}
              </p>
            </div>

            {wrongAnswers.length > 0 && (
              <div className="space-y-4">
                <h3 className="text-lg font-semibold text-foreground">
                  Incorrect answers:
                </h3>
                <div className="space-y-4">
                  {wrongAnswers.map((wrong) => (
                    <div
                      key={wrong.question.id}
                      className="bg-white dark:bg-card rounded-lg p-4 space-y-2 border-2 border-border"
                    >
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-2">
                          <ThaiCharacterDisplay
                            character={wrong.question.thai}
                            size="text-2xl"
                          />
                          <Button
                            variant="ghost"
                            size="icon"
                            onClick={() => speak(wrong.question.thai)}
                            className="h-8 w-8 rounded-full"
                          >
                            <Volume2 className="w-4 h-4" />
                          </Button>
                        </div>
                        <span className="text-muted-foreground text-sm">
                          {wrong.question.romanized}
                        </span>
                      </div>
                      <div className="flex items-center gap-2 text-sm">
                        <span className="text-green-600 dark:text-green-400 font-medium">
                          Correct: {wrong.question.meaning}
                        </span>
                        <X className="w-4 h-4 text-muted-foreground/50" />
                        <span className="text-red-600 dark:text-red-400 font-medium">
                          You chose: {wrong.playerAnswer.meaning}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            <div className="space-y-2 pt-4">
              <Button
                onClick={() => setGameState("playing")}
                className="w-full flex items-center justify-center gap-2 bg-primary hover:bg-primary/90 text-primary-foreground"
              >
                <RefreshCw className="w-4 h-4" />
                Play Again
              </Button>
              <Button
                onClick={handleReturnToMenu}
                variant="outline"
                className="w-full border-2 hover:bg-accent/10 dark:border-primary/30 dark:hover:border-primary dark:hover:bg-primary/10 dark:hover:text-white"
              >
                Return to Menu
              </Button>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
};

================
File: src/components/game/ThemeToggle.tsx
================
"use client";

import { Moon, Sun } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useTheme } from "@/context/ThemeContext";

export function ThemeToggle() {
  const { theme, toggleTheme } = useTheme();

  return (
    <Button
      variant="ghost"
      size="icon"
      onClick={toggleTheme}
      className="fixed top-4 left-4 rounded-full"
      title={theme === "light" ? "Switch to Dark Mode" : "Switch to Light Mode"}
    >
      {theme === "light" ? (
        <Moon className="h-5 w-5" />
      ) : (
        <Sun className="h-5 w-5" />
      )}
    </Button>
  );
}

================
File: src/components/ui/alert.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }

================
File: src/components/ui/badge.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

================
File: src/components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: src/components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: src/components/ui/collapsible.tsx
================
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }

================
File: src/components/ui/label.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

================
File: src/components/ui/logo.tsx
================
"use client";

import React from "react";

interface LogoProps {
  className?: string;
}

export const Logo: React.FC<LogoProps> = ({ className = "" }) => {
  return (
    <div
      className={`flex flex-col items-center select-none group ${className}`}
    >
      <div className="relative w-16 h-16 mb-3">
        {/* Main gradient background */}
        <div className="absolute inset-0 bg-gradient-to-b from-[#A51931] via-white to-primary rounded-xl shadow-lg transform rotate-45"></div>

        {/* Inner white square with Thai character */}
        <div className="absolute inset-2 bg-white/90 backdrop-blur-sm rounded-lg transform rotate-45 flex items-center justify-center">
          <span className="text-2xl font-bold transform -rotate-45 bg-gradient-to-br from-primary to-[#A51931] bg-clip-text text-transparent">
            ก
          </span>
        </div>
      </div>

      {/* Title with hover animation */}
      <h1 className="text-xl font-bold text-primary">Thai Practice</h1>

      {/* Single gradient bar that matches the main logo */}
      <div className="mt-2 h-1 w-24 bg-gradient-to-r from-[#A51931] via-white to-primary rounded-full"></div>
    </div>
  );
};

================
File: src/components/ui/progress.tsx
================
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

================
File: src/components/ui/slider.tsx
================
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }

================
File: src/components/ui/switch.tsx
================
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

================
File: src/components/ThemeScript.tsx
================
"use client";

import { useEffect } from "react";

export const ThemeScript = () => {
  useEffect(() => {
    const theme = localStorage.getItem("theme") ?? "light";
    document.documentElement.classList.add(theme);
  }, []);

  return null;
};

================
File: src/constants/content/classifiers.ts
================
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

const classifiers: PhraseContent[] = [
  {
    id: "classifier-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "คน",
    romanized: "khon",
    meaning: "people/person",
  },
  {
    id: "classifier-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "ตัว",
    romanized: "tua",
    meaning: "animals/things",
  },
  {
    id: "classifier-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "ลูก",
    romanized: "lûuk",
    meaning: "round objects",
  },
  {
    id: "classifier-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "ชิ้น",
    romanized: "chín",
    meaning: "flat objects",
  },
  {
    id: "classifier-5",
    type: "phrase",
    difficulty: "beginner",
    thai: "ห้อง",
    romanized: "hǒng",
    meaning: "rooms/buildings",
  },
  {
    id: "classifier-6",
    type: "phrase",
    difficulty: "beginner",
    thai: "เล่ม",
    romanized: "lêm",
    meaning: "books",
  },
  {
    id: "classifier-7",
    type: "phrase",
    difficulty: "beginner",
    thai: "คัน",
    romanized: "khan",
    meaning: "vehicles",
  },
  {
    id: "classifier-8",
    type: "phrase",
    difficulty: "beginner",
    thai: "ดอก",
    romanized: "dòk",
    meaning: "flowers",
  },
  {
    id: "classifier-9",
    type: "phrase",
    difficulty: "beginner",
    thai: "ใบ",
    romanized: "bai",
    meaning: "leaves/sheets",
  },
  {
    id: "classifier-10",
    type: "phrase",
    difficulty: "beginner",
    thai: "ด้าม",
    romanized: "dâam",
    meaning: "long/cylindrical objects",
  },
];

export const classifiersContent: CategoryContent = {
  categoryId: "classifiers",
  items: classifiers,
};

================
File: src/constants/content/colors.ts
================
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

const colors: PhraseContent[] = [
  {
    id: "color-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "สีขาว",
    romanized: "sǐi-khǎao",
    meaning: "white",
  },
  {
    id: "color-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "สีดำ",
    romanized: "sǐi-dam",
    meaning: "black",
  },
  {
    id: "color-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "สีแดง",
    romanized: "sǐi-dɛɛng",
    meaning: "red",
  },
  {
    id: "color-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "สีเขียว",
    romanized: "sǐi-khǐaw",
    meaning: "green",
  },
  {
    id: "color-5",
    type: "phrase",
    difficulty: "beginner",
    thai: "สีน้ำเงิน",
    romanized: "sǐi-nám-ngəən",
    meaning: "blue",
  },
  {
    id: "color-6",
    type: "phrase",
    difficulty: "beginner",
    thai: "สีเหลือง",
    romanized: "sǐi-lʉ̌ang",
    meaning: "yellow",
  },
  {
    id: "color-7",
    type: "phrase",
    difficulty: "beginner",
    thai: "สีส้ม",
    romanized: "sǐi-sôm",
    meaning: "orange",
  },
  {
    id: "color-8",
    type: "phrase",
    difficulty: "beginner",
    thai: "สีชมพู",
    romanized: "sǐi-chom-phuu",
    meaning: "pink",
  },
  {
    id: "color-9",
    type: "phrase",
    difficulty: "beginner",
    thai: "สีน้ำตาล",
    romanized: "sǐi-nám-taan",
    meaning: "brown",
  },
  {
    id: "color-10",
    type: "phrase",
    difficulty: "beginner",
    thai: "สีเทา",
    romanized: "sǐi-thao",
    meaning: "gray",
  },
  {
    id: "color-q-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "สีอะไร",
    romanized: "sǐi-à-rai",
    meaning: "what color?",
  },
];

export const colorsContent: CategoryContent = {
  categoryId: "colors",
  items: colors,
};

================
File: src/constants/content/commonPhrases.ts
================
// src/constants/content/commonPhrases.ts
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

const phrases: PhraseContent[] = [
  // Greetings
  {
    id: "greeting-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "สวัสดี",
    romanized: "sawadee",
    meaning: "hello",
  },
  {
    id: "greeting-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "สวัสดีค่ะ",
    romanized: "sawadee ka",
    meaning: "hello (female speaking)",
  },
  {
    id: "greeting-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "สวัสดีครับ",
    romanized: "sawadee krap",
    meaning: "hello (male speaking)",
  },

  // Basic Responses
  {
    id: "basic-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "ขอบคุณ",
    romanized: "khop khun",
    meaning: "thank you",
  },
  {
    id: "basic-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "ไม่เป็นไร",
    romanized: "mai pen rai",
    meaning: "you're welcome/no worries",
  },
  {
    id: "basic-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "ใช่",
    romanized: "chai",
    meaning: "yes",
  },
  {
    id: "basic-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "ไม่",
    romanized: "mai",
    meaning: "no",
  },

  // Common Questions
  {
    id: "question-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "คุณชื่ออะไร",
    romanized: "khun chuu arai",
    meaning: "what is your name?",
  },
  {
    id: "question-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "สบายดีไหม",
    romanized: "sabai dee mai",
    meaning: "how are you?",
  },
  {
    id: "question-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "เท่าไหร่",
    romanized: "tao rai",
    meaning: "how much?",
  },

  // States and Feelings
  {
    id: "state-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "สบายดี",
    romanized: "sabai dee",
    meaning: "I'm fine",
  },
  {
    id: "state-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "หิว",
    romanized: "hiw",
    meaning: "hungry",
  },
  {
    id: "state-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "เหนื่อย",
    romanized: "neuy",
    meaning: "tired",
  },
  {
    id: "state-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "ร้อน",
    romanized: "ron",
    meaning: "hot (weather/feeling)",
  },

  // Communication
  {
    id: "comm-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "เข้าใจ",
    romanized: "kao jai",
    meaning: "understand",
  },
  {
    id: "comm-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "ไม่เข้าใจ",
    romanized: "mai kao jai",
    meaning: "don't understand",
  },
  {
    id: "comm-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "พูดช้าๆ",
    romanized: "pood cha cha",
    meaning: "speak slowly",
  },
  {
    id: "comm-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "พูดอีกครั้ง",
    romanized: "pood eek krang",
    meaning: "say it again",
  },

  // Courtesy
  {
    id: "courtesy-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "ขอโทษ",
    romanized: "kho thot",
    meaning: "sorry/excuse me",
  },
  {
    id: "courtesy-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "กรุณา",
    romanized: "ga-ru-na",
    meaning: "please",
  },

  // Common Responses
  {
    id: "response-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "ได้",
    romanized: "dai",
    meaning: "can/okay",
  },
  {
    id: "response-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "ไม่ได้",
    romanized: "mai dai",
    meaning: "cannot",
  },
  {
    id: "response-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "ดี",
    romanized: "dee",
    meaning: "good",
  },
  {
    id: "response-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "ไม่ดี",
    romanized: "mai dee",
    meaning: "not good",
  },
];

export const commonPhrasesContent: CategoryContent = {
  categoryId: "common-phrases",
  items: phrases,
};

================
File: src/constants/content/directions.ts
================
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

const directionPhrases: PhraseContent[] = [
  {
    id: "direction-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "ไปทางไหน",
    romanized: "bpai taang nai",
    meaning: "Which way do I go?",
  },
  {
    id: "direction-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "ตรงไป",
    romanized: "tróng bpai",
    meaning: "Go straight",
  },
  {
    id: "direction-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "เลี้ยวซ้าย",
    romanized: "lío sái",
    meaning: "Turn left",
  },
  {
    id: "direction-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "เลี้ยวขวา",
    romanized: "lío kăa",
    meaning: "Turn right",
  },
  {
    id: "direction-5",
    type: "phrase",
    difficulty: "beginner",
    thai: "อยู่ตรงนี้",
    romanized: "yùu tróng-ní",
    meaning: "It's right here",
  },
  {
    id: "direction-6",
    type: "phrase",
    difficulty: "beginner",
    thai: "ไกลแค่ไหน",
    romanized: "gai kɛ̀ nai",
    meaning: "How far is it?",
  },
  {
    id: "direction-7",
    type: "phrase",
    difficulty: "beginner",
    thai: "อยู่ใกล้ๆ",
    romanized: "yùu glai glai",
    meaning: "It's nearby",
  },
  {
    id: "direction-8",
    type: "phrase",
    difficulty: "beginner",
    thai: "ไปจนสุดทาง",
    romanized: "bpai jon sùt taang",
    meaning: "Go all the way to the end",
  },
  {
    id: "direction-9",
    type: "phrase",
    difficulty: "beginner",
    thai: "อยู่ตรงข้ามกัน",
    romanized: "yùu tróng kăam gan",
    meaning: "It's across from here",
  },
  {
    id: "direction-10",
    type: "phrase",
    difficulty: "beginner",
    thai: "เดินไปตามถนน",
    romanized: "dern bpai tam tà-nǒn",
    meaning: "Walk down the street",
  },
];

export const directionContent: CategoryContent = {
  categoryId: "directions",
  items: directionPhrases,
};

================
File: src/constants/content/familyAndRelationships.ts
================
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

const familyAndRelationships: PhraseContent[] = [
  // Core Family Terms
  {
    id: "family-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "พ่อ",
    romanized: "phɔ̂ɔ",
    meaning: "father",
  },
  {
    id: "family-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "แม่",
    romanized: "mɛ̂ɛ",
    meaning: "mother",
  },
  {
    id: "family-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "ลูกชาย",
    romanized: "lûuk-chaai",
    meaning: "son",
  },
  {
    id: "family-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "ลูกสาว",
    romanized: "lûuk-sǎao",
    meaning: "daughter",
  },

  // Siblings
  {
    id: "family-5",
    type: "phrase",
    difficulty: "beginner",
    thai: "พี่ชาย",
    romanized: "phîi-chaai",
    meaning: "older brother",
  },
  {
    id: "family-6",
    type: "phrase",
    difficulty: "beginner",
    thai: "พี่สาว",
    romanized: "phîi-sǎao",
    meaning: "older sister",
  },
  {
    id: "family-7",
    type: "phrase",
    difficulty: "beginner",
    thai: "น้องชาย",
    romanized: "nɔ́ɔng-chaai",
    meaning: "younger brother",
  },
  {
    id: "family-8",
    type: "phrase",
    difficulty: "beginner",
    thai: "น้องสาว",
    romanized: "nɔ́ɔng-sǎao",
    meaning: "younger sister",
  },

  // Marriage Relations
  {
    id: "family-9",
    type: "phrase",
    difficulty: "beginner",
    thai: "สามี",
    romanized: "sǎa-mii",
    meaning: "husband",
  },
  {
    id: "family-10",
    type: "phrase",
    difficulty: "beginner",
    thai: "ภรรยา",
    romanized: "phan-ra-yaa",
    meaning: "wife",
  },
  {
    id: "family-11",
    type: "phrase",
    difficulty: "beginner",
    thai: "แฟน",
    romanized: "fɛɛn",
    meaning: "partner/girlfriend/boyfriend",
  },

  // Basic Social Relationships
  {
    id: "relation-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "เพื่อน",
    romanized: "phûean",
    meaning: "friend",
  },
  {
    id: "relation-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "เพื่อนร่วมงาน",
    romanized: "phûean-rûam-ngaan",
    meaning: "colleague",
  },

  // Essential Respectful Terms
  {
    id: "respect-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "พี่",
    romanized: "phîi",
    meaning: "older person (respectful)",
  },
  {
    id: "respect-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "น้อง",
    romanized: "nɔ́ɔng",
    meaning: "younger person (respectful)",
  },

  // Basic Questions
  {
    id: "relation-q-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "มีพี่น้องไหม",
    romanized: "mii-phîi-nɔ́ɔng-mǎi",
    meaning: "do you have siblings?",
  },
  {
    id: "relation-q-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "แต่งงานหรือยัง",
    romanized: "tɛ̀ɛng-ngaan-rʉ̌ʉ-yang",
    meaning: "are you married?",
  },
];

export const familyAndRelationshipsContent: CategoryContent = {
  categoryId: "family-relationships",
  items: familyAndRelationships,
};

================
File: src/constants/content/foodAndDrink.ts
================
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

const foodAndDrink: PhraseContent[] = [
  {
    id: "food-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "ข้าว",
    romanized: "khao",
    meaning: "rice",
  },
  {
    id: "food-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "ผัก",
    romanized: "phak",
    meaning: "vegetable",
  },
  {
    id: "food-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "เนื้อ",
    romanized: "neuua",
    meaning: "meat",
  },
  {
    id: "food-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "ปลา",
    romanized: "bplaa",
    meaning: "fish",
  },
  {
    id: "food-5",
    type: "phrase",
    difficulty: "beginner",
    thai: "ผลไม้",
    romanized: "phon-ma-i",
    meaning: "fruit",
  },
  {
    id: "drink-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "น้ำ",
    romanized: "naam",
    meaning: "water",
  },
  {
    id: "drink-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "กาแฟ",
    romanized: "gaa-fae",
    meaning: "coffee",
  },
  {
    id: "drink-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "ชา",
    romanized: "chaa",
    meaning: "tea",
  },
  {
    id: "drink-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "น้ำผลไม้",
    romanized: "naam-phon-ma-i",
    meaning: "fruit juice",
  },
  {
    id: "drink-5",
    type: "phrase",
    difficulty: "beginner",
    thai: "นม",
    romanized: "nom",
    meaning: "milk",
  },
];

export const foodAndDrinkContent: CategoryContent = {
  categoryId: "food-drink",
  items: foodAndDrink,
};

================
File: src/constants/content/index.ts
================
// src/constants/content/index.ts
import { commonPhrasesContent } from "./commonPhrases";
import type { CategoryContent } from "@/types/ContentTypes";
import type { LearningCategoryId } from "@/types/LearningCategory";
import { thaiScriptContent } from "./thaiScript";
import { numbersContent } from "./numbers";
import { foodAndDrinkContent } from "./foodAndDrink";
import { pronounsContent } from "./pronouns";
import { travelContent } from "./travel";
import { directionContent } from "./directions";
import { classifiersContent } from "./classifiers";
import { thaiScriptAdvancedContent } from "./thaiScriptAdvanced";
import { thaiScriptIntermediateContent } from "./thaiScriptIntermediate";
import { timeAndCalendarContent } from "./timeAndCalendar";
import { familyAndRelationshipsContent } from "./familyAndRelationships";
import { colorsContent } from "./colors";
import { questionWordsContent } from "./questionWords";

export const CATEGORY_CONTENT: Partial<
  Record<LearningCategoryId, CategoryContent>
> = {
  "common-phrases": commonPhrasesContent,
  "thai-script": thaiScriptContent,
  "thai-script-intermediate": thaiScriptIntermediateContent,
  "thai-script-advanced": thaiScriptAdvancedContent,
  numbers: numbersContent,
  "food-drink": foodAndDrinkContent,
  travel: travelContent,
  pronouns: pronounsContent,
  directions: directionContent,
  classifiers: classifiersContent,
  "time-calendar": timeAndCalendarContent,
  "family-relationships": familyAndRelationshipsContent,
  colors: colorsContent,
  "question-words": questionWordsContent,
};

// Helper functions
export const isContentAvailable = (categoryId: LearningCategoryId): boolean => {
  return categoryId in CATEGORY_CONTENT;
};

export const getCategoryContent = (
  categoryId: LearningCategoryId
): CategoryContent | undefined => {
  return CATEGORY_CONTENT[categoryId];
};

export const getCategoryItemCount = (
  categoryId: LearningCategoryId
): number => {
  return CATEGORY_CONTENT[categoryId]?.items.length ?? 0;
};

// You might want to add these utility functions for the future:
export const getAvailableCategories = (): LearningCategoryId[] => {
  return Object.keys(CATEGORY_CONTENT) as LearningCategoryId[];
};

export const getTotalContentItems = (): number => {
  return Object.values(CATEGORY_CONTENT).reduce(
    (total, category) => total + (category?.items.length ?? 0),
    0
  );
};

================
File: src/constants/content/numbers.ts
================
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

const numbers: PhraseContent[] = [
  {
    id: "number-0",
    type: "phrase",
    difficulty: "beginner",
    thai: "ศูนย์",
    romanized: "song",
    meaning: "0 (zero)",
  },
  {
    id: "number-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "หนึ่ง",
    romanized: "neung",
    meaning: "1 (one)",
  },
  {
    id: "number-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "สอง",
    romanized: "song",
    meaning: "2 (two)",
  },
  {
    id: "number-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "สาม",
    romanized: "saam",
    meaning: "3 (three)",
  },
  {
    id: "number-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "สี่",
    romanized: "see",
    meaning: "4 (four)",
  },
  {
    id: "number-5",
    type: "phrase",
    difficulty: "beginner",
    thai: "ห้า",
    romanized: "haa",
    meaning: "5 (five)",
  },
  {
    id: "number-6",
    type: "phrase",
    difficulty: "beginner",
    thai: "หก",
    romanized: "hok",
    meaning: "6 (six)",
  },
  {
    id: "number-7",
    type: "phrase",
    difficulty: "beginner",
    thai: "เจ็ด",
    romanized: "jet",
    meaning: "7 (seven)",
  },
  {
    id: "number-8",
    type: "phrase",
    difficulty: "beginner",
    thai: "แปด",
    romanized: "paet",
    meaning: "8 (eight)",
  },
  {
    id: "number-9",
    type: "phrase",
    difficulty: "beginner",
    thai: "เก้า",
    romanized: "kao",
    meaning: "9 (nine)",
  },
  {
    id: "number-10",
    type: "phrase",
    difficulty: "beginner",
    thai: "สิบ",
    romanized: "sip",
    meaning: "10 (ten)",
  },
  {
    id: "number-11",
    type: "phrase",
    difficulty: "beginner",
    thai: "สิบเอ็ด",
    romanized: "sip-et",
    meaning: "11 (eleven)",
  },
  {
    id: "number-12",
    type: "phrase",
    difficulty: "beginner",
    thai: "สิบสอง",
    romanized: "sip-song",
    meaning: "12 (twelve)",
  },
  {
    id: "number-13",
    type: "phrase",
    difficulty: "beginner",
    thai: "สิบสาม",
    romanized: "sip-saam",
    meaning: "13 (thirteen)",
  },
  {
    id: "number-14",
    type: "phrase",
    difficulty: "beginner",
    thai: "สิบสี่",
    romanized: "sip-see",
    meaning: "14 (fourteen)",
  },
  {
    id: "number-15",
    type: "phrase",
    difficulty: "beginner",
    thai: "สิบห้า",
    romanized: "sip-haa",
    meaning: "15 (fifteen)",
  },
];

export const numbersContent: CategoryContent = {
  categoryId: "numbers",
  items: numbers,
};

================
File: src/constants/content/pronouns.ts
================
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

const pronouns: PhraseContent[] = [
  {
    id: "pronoun-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "ฉัน",
    romanized: "chan",
    meaning: "I (formal)",
  },
  {
    id: "pronoun-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "ผม",
    romanized: "phom",
    meaning: "I (male speaker)",
  },
  {
    id: "pronoun-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "ดิฉัน",
    romanized: "di-chan",
    meaning: "I (female speaker)",
  },
  {
    id: "pronoun-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "เขา",
    romanized: "khao",
    meaning: "he/she/it",
  },
  {
    id: "pronoun-5",
    type: "phrase",
    difficulty: "beginner",
    thai: "พวกเรา",
    romanized: "phuak-rao",
    meaning: "we",
  },
  {
    id: "pronoun-6",
    type: "phrase",
    difficulty: "beginner",
    thai: "พวกคุณ",
    romanized: "phuak-khun",
    meaning: "you (plural)",
  },
  {
    id: "pronoun-7",
    type: "phrase",
    difficulty: "beginner",
    thai: "คุณ",
    romanized: "khun",
    meaning: "you (singular)",
  },
  {
    id: "pronoun-8",
    type: "phrase",
    difficulty: "beginner",
    thai: "พวกเขา",
    romanized: "phuak-khao",
    meaning: "they",
  },
];

export const pronounsContent: CategoryContent = {
  categoryId: "pronouns",
  items: pronouns,
};

================
File: src/constants/content/questionWords.ts
================
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

const questionWords: PhraseContent[] = [
  // Who
  {
    id: "who-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "ใคร",
    romanized: "khrai",
    meaning: "who",
  },
  {
    id: "who-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "ของใคร",
    romanized: "khɔ̌ɔng-khrai",
    meaning: "whose",
  },

  // What
  {
    id: "what-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "อะไร",
    romanized: "à-rai",
    meaning: "what",
  },
  {
    id: "what-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "ทำอะไร",
    romanized: "tham-à-rai",
    meaning: "what are you doing",
  },

  // Where
  {
    id: "where-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "ที่ไหน",
    romanized: "thîi-nǎi",
    meaning: "where",
  },
  {
    id: "where-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "ไปไหน",
    romanized: "bpai-nǎi",
    meaning: "where are you going",
  },

  // When
  {
    id: "when-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "เมื่อไหร่",
    romanized: "mʉ̂a-rài",
    meaning: "when",
  },
  {
    id: "when-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "กี่โมง",
    romanized: "gìi-moong",
    meaning: "what time",
  },

  // Why
  {
    id: "why-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "ทำไม",
    romanized: "tham-mai",
    meaning: "why",
  },
  {
    id: "why-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "เพราะอะไร",
    romanized: "prɔ́-à-rai",
    meaning: "for what reason",
  },

  // How
  {
    id: "how-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "อย่างไร",
    romanized: "yàang-rai",
    meaning: "how",
  },
  {
    id: "how-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "เท่าไหร่",
    romanized: "thâo-rài",
    meaning: "how much/many",
  },

  // Common Question Particle
  {
    id: "particle-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "ไหม",
    romanized: "mǎi",
    meaning: "yes/no question particle",
  },
  {
    id: "particle-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "หรือ",
    romanized: "rʉ̌ʉ",
    meaning: "or/question particle",
  },
];

export const questionWordsContent: CategoryContent = {
  categoryId: "question-words",
  items: questionWords,
};

================
File: src/constants/content/thaiScript.ts
================
// src/constants/content/thaiScript.ts
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

// Basic consonants that form core vocabulary
const consonants: PhraseContent[] = [
  {
    id: "consonant-k",
    type: "phrase",
    difficulty: "beginner",
    thai: "ก",
    romanized: "gɔɔ-gài",
    meaning: "Chicken consonant (K sound)",
    extra: {
      wordThai: "ก ไก่",
      wordMeaning: "chicken",
      class: "mid-class",
      sound: "k",
    },
  },
  {
    id: "consonant-n",
    type: "phrase",
    difficulty: "beginner",
    thai: "น",
    romanized: "nɔɔ-nuu",
    meaning: "Mouse consonant (N sound)",
    extra: {
      wordThai: "น หนู",
      wordMeaning: "mouse",
      class: "low-class",
      sound: "n",
    },
  },
  {
    id: "consonant-m",
    type: "phrase",
    difficulty: "beginner",
    thai: "ม",
    romanized: "mɔɔ-mǎa",
    meaning: "Horse consonant (M sound)",
    extra: {
      wordThai: "ม ม้า",
      wordMeaning: "horse",
      class: "low-class",
      sound: "m",
    },
  },
];

// Essential vowels for basic word formation
const vowels: PhraseContent[] = [
  {
    id: "vowel-a-short",
    type: "phrase",
    difficulty: "beginner",
    thai: "ะ",
    romanized: "sara a",
    meaning: "Short A vowel",
    extra: {
      wordThai: "จะ",
      wordMeaning: "will",
      sound: "short a",
    },
  },
  {
    id: "vowel-a-long",
    type: "phrase",
    difficulty: "beginner",
    thai: "า",
    romanized: "sara aa",
    meaning: "Long A vowel",
    extra: {
      wordThai: "มา",
      wordMeaning: "come",
      sound: "long aa",
    },
  },
  {
    id: "vowel-i",
    type: "phrase",
    difficulty: "beginner",
    thai: "ิ",
    romanized: "sara i",
    meaning: "Short I vowel",
    extra: {
      wordThai: "มิ",
      wordMeaning: "not",
      sound: "short i",
    },
  },
];

// Simple tone marks for basic pronunciation
const simpleTones: PhraseContent[] = [
  {
    id: "tone-low",
    type: "phrase",
    difficulty: "beginner",
    thai: "่",
    romanized: "mai eek",
    meaning: "Low tone mark",
    extra: {
      wordThai: "ม่า",
      wordMeaning: "mother (informal)",
      sound: "low tone",
    },
  },
];

export const thaiScriptContent: CategoryContent = {
  categoryId: "thai-script",
  items: [...consonants, ...vowels, ...simpleTones],
};

================
File: src/constants/content/thaiScriptAdvanced.ts
================
// src/constants/content/thaiScriptAdvanced.ts
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

// Rare consonants used in formal/literary Thai
const rareConsonants: PhraseContent[] = [
  {
    id: "consonant-zh",
    type: "phrase",
    difficulty: "advanced",
    thai: "ฌ",
    romanized: "chɔɔ-chəə",
    meaning: "Tree consonant (CH sound)",
    extra: {
      wordThai: "ฌ เฌอ",
      wordMeaning: "tree (archaic)",
      class: "high-class",
      sound: "ch",
    },
  },
  {
    id: "consonant-dt",
    type: "phrase",
    difficulty: "advanced",
    thai: "ฎ",
    romanized: "dɔɔ-chá-daa",
    meaning: "Headdress consonant (D sound)",
    extra: {
      wordThai: "ฎ ชฎา",
      wordMeaning: "headdress",
      class: "mid-class",
      sound: "d",
    },
  },
  {
    id: "consonant-th",
    type: "phrase",
    difficulty: "advanced",
    thai: "ฐ",
    romanized: "thɔɔ-thǎan",
    meaning: "Base consonant (TH sound)",
    extra: {
      wordThai: "ฐ ฐาน",
      wordMeaning: "base/pedestal",
      class: "high-class",
      sound: "th",
    },
  },
];

// Complex vowel combinations used in formal/literary Thai
const complexVowels: PhraseContent[] = [
  {
    id: "vowel-oe-short",
    type: "phrase",
    difficulty: "advanced",
    thai: "เ-ิ",
    romanized: "sara oe",
    meaning: "Short OE vowel sound",
    extra: {
      wordThai: "เกิด",
      wordMeaning: "to be born",
      sound: "short oe",
    },
  },
  {
    id: "vowel-ia-short",
    type: "phrase",
    difficulty: "advanced",
    thai: "เ-ียะ",
    romanized: "sara ia",
    meaning: "Short IA vowel sound",
    extra: {
      wordThai: "เปี๊ยะ",
      wordMeaning: "pastry",
      sound: "short ia",
    },
  },
  {
    id: "vowel-oe-complex",
    type: "phrase",
    difficulty: "advanced",
    thai: "เ-็อ",
    romanized: "sara oe",
    meaning: "Complex OE vowel sound",
    extra: {
      wordThai: "เล็กๆ",
      wordMeaning: "small (repetitive)",
      sound: "short oe",
    },
  },
];

// Sanskrit/Pali characters used in formal writing
const sanskritChars: PhraseContent[] = [
  {
    id: "sanskrit-ru",
    type: "phrase",
    difficulty: "advanced",
    thai: "ฤ",
    romanized: "rɯ",
    meaning: "Sanskrit RU vowel",
    extra: {
      wordThai: "ฤดู",
      wordMeaning: "season",
      sound: "rʉ/ri/rɯ",
    },
  },
  {
    id: "sanskrit-lu",
    type: "phrase",
    difficulty: "advanced",
    thai: "ฦ",
    romanized: "lɯ",
    meaning: "Sanskrit LU vowel",
    extra: {
      wordThai: "ฦๅ",
      wordMeaning: "archaic character",
      sound: "lʉ",
    },
  },
  {
    id: "sanskrit-om",
    type: "phrase",
    difficulty: "advanced",
    thai: "ๆ",
    romanized: "máai-yammók",
    meaning: "Repetition mark",
    extra: {
      wordThai: "เล็กๆ",
      wordMeaning: "small (repetitive)",
      sound: "repeat previous word",
    },
  },
];

// Special characters and symbols
const specialChars: PhraseContent[] = [
  {
    id: "number-indicator",
    type: "phrase",
    difficulty: "advanced",
    thai: "ฯ",
    romanized: "páiyaannói",
    meaning: "Abbreviation mark",
    extra: {
      wordThai: "มหาฯ",
      wordMeaning: "abbreviation marker",
      sound: "indicates abbreviation",
    },
  },
  {
    id: "leader",
    type: "phrase",
    difficulty: "advanced",
    thai: "ฯลฯ",
    romanized: "páiyaanyái",
    meaning: "Et cetera mark",
    extra: {
      wordThai: "ฯลฯ",
      wordMeaning: "et cetera",
      sound: "indicates continuation",
    },
  },
];

export const thaiScriptAdvancedContent: CategoryContent = {
  categoryId: "thai-script-advanced",
  items: [
    ...rareConsonants,
    ...complexVowels,
    ...sanskritChars,
    ...specialChars,
  ],
};

================
File: src/constants/content/thaiScriptIntermediate.ts
================
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

const highClassConsonants: PhraseContent[] = [
  {
    id: "consonant-kh1",
    type: "phrase",
    difficulty: "intermediate",
    thai: "ข",
    romanized: "khɔɔ-khài",
    meaning: "Egg consonant (KH sound)",
    extra: {
      wordThai: "ข ไข่",
      wordMeaning: "egg",
      class: "high-class",
      sound: "kh",
    },
  },
  {
    id: "consonant-ch",
    type: "phrase",
    difficulty: "intermediate",
    thai: "ฉ",
    romanized: "chɔɔ-chìng",
    meaning: "Cymbals consonant (CH sound)",
    extra: {
      wordThai: "ฉ ฉิ่ง",
      wordMeaning: "cymbals",
      class: "high-class",
      sound: "ch",
    },
  },
  {
    id: "consonant-s1",
    type: "phrase",
    difficulty: "intermediate",
    thai: "ส",
    romanized: "sɔɔ-sʉ̌a",
    meaning: "Tiger consonant (S sound)",
    extra: {
      wordThai: "ส เสือ",
      wordMeaning: "tiger",
      class: "high-class",
      sound: "s",
    },
  },
];

// Complex vowel combinations
const complexVowels: PhraseContent[] = [
  {
    id: "vowel-ae",
    type: "phrase",
    difficulty: "intermediate",
    thai: "แ-ะ",
    romanized: "sara ae",
    meaning: "Short AE vowel sound",
    extra: {
      wordThai: "แพะ",
      wordMeaning: "goat",
      sound: "short ae",
    },
  },
  {
    id: "vowel-ae-long",
    type: "phrase",
    difficulty: "intermediate",
    thai: "แ-",
    romanized: "sara ae",
    meaning: "Long AE vowel sound",
    extra: {
      wordThai: "แพ",
      wordMeaning: "raft",
      sound: "long ae",
    },
  },
  {
    id: "vowel-oo",
    type: "phrase",
    difficulty: "intermediate",
    thai: "ื-อ",
    romanized: "sara ʉʉ",
    meaning: "Long UE vowel sound",
    extra: {
      wordThai: "มือ",
      wordMeaning: "hand",
      sound: "long ʉʉ",
    },
  },
];

// Tone marks with rules
const toneMarks: PhraseContent[] = [
  {
    id: "tone-falling",
    type: "phrase",
    difficulty: "intermediate",
    thai: "้",
    romanized: "mai toh",
    meaning: "Falling tone mark",
    extra: {
      wordThai: "น้ำ",
      wordMeaning: "water",
      sound: "falling tone",
    },
  },
  {
    id: "tone-high",
    type: "phrase",
    difficulty: "intermediate",
    thai: "๊",
    romanized: "mai tri",
    meaning: "High tone mark",
    extra: {
      wordThai: "ม๊าก",
      wordMeaning: "very (informal)",
      sound: "high tone",
    },
  },
  {
    id: "tone-rising",
    type: "phrase",
    difficulty: "intermediate",
    thai: "๋",
    romanized: "mai chattawa",
    meaning: "Rising tone mark",
    extra: {
      wordThai: "เป๋า",
      wordMeaning: "wallet",
      sound: "rising tone",
    },
  },
];

export const thaiScriptIntermediateContent: CategoryContent = {
  categoryId: "thai-script-intermediate",
  items: [...highClassConsonants, ...complexVowels, ...toneMarks],
};

================
File: src/constants/content/timeAndCalendar.ts
================
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

const timeAndCalendar: PhraseContent[] = [
  // Days of the Week
  {
    id: "day-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "วันจันทร์",
    romanized: "wan-jan",
    meaning: "Monday",
  },
  {
    id: "day-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "วันอังคาร",
    romanized: "wan-ang-khan",
    meaning: "Tuesday",
  },
  {
    id: "day-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "วันพุธ",
    romanized: "wan-phut",
    meaning: "Wednesday",
  },
  {
    id: "day-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "วันพฤหัสบดี",
    romanized: "wan-pha-rue-hat-sa-ba-dee",
    meaning: "Thursday",
  },
  {
    id: "day-5",
    type: "phrase",
    difficulty: "beginner",
    thai: "วันศุกร์",
    romanized: "wan-suk",
    meaning: "Friday",
  },
  {
    id: "day-6",
    type: "phrase",
    difficulty: "beginner",
    thai: "วันเสาร์",
    romanized: "wan-sao",
    meaning: "Saturday",
  },
  {
    id: "day-7",
    type: "phrase",
    difficulty: "beginner",
    thai: "วันอาทิตย์",
    romanized: "wan-aa-thit",
    meaning: "Sunday",
  },

  // Months
  {
    id: "month-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "มกราคม",
    romanized: "ma-ka-ra-khom",
    meaning: "January",
  },
  {
    id: "month-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "กุมภาพันธ์",
    romanized: "kum-pha-phan",
    meaning: "February",
  },
  {
    id: "month-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "มีนาคม",
    romanized: "mee-na-khom",
    meaning: "March",
  },

  // Time-related Words
  {
    id: "time-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "นาฬิกา",
    romanized: "na-li-ka",
    meaning: "o'clock",
  },
  {
    id: "time-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "นาที",
    romanized: "na-thee",
    meaning: "minute",
  },
  {
    id: "time-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "ชั่วโมง",
    romanized: "chua-mong",
    meaning: "hour",
  },

  // Time Expressions
  {
    id: "time-exp-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "เมื่อวาน",
    romanized: "muea-waan",
    meaning: "yesterday",
  },
  {
    id: "time-exp-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "วันนี้",
    romanized: "wan-nee",
    meaning: "today",
  },
  {
    id: "time-exp-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "พรุ่งนี้",
    romanized: "phrung-nee",
    meaning: "tomorrow",
  },
  {
    id: "time-exp-4",
    type: "phrase",
    difficulty: "intermediate",
    thai: "สัปดาห์หน้า",
    romanized: "sap-da-na",
    meaning: "next week",
  },
  {
    id: "time-exp-5",
    type: "phrase",
    difficulty: "intermediate",
    thai: "เดือนที่แล้ว",
    romanized: "duean-thi-laew",
    meaning: "last month",
  },

  // Common Time Questions
  {
    id: "time-q-1",
    type: "phrase",
    difficulty: "intermediate",
    thai: "กี่โมงแล้ว",
    romanized: "kee-mong-laew",
    meaning: "what time is it?",
  },
  {
    id: "time-q-2",
    type: "phrase",
    difficulty: "intermediate",
    thai: "วันไหน",
    romanized: "wan-nai",
    meaning: "which day?",
  },

  // Parts of Day
  {
    id: "day-part-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "เช้า",
    romanized: "chao",
    meaning: "morning",
  },
  {
    id: "day-part-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "บ่าย",
    romanized: "baai",
    meaning: "afternoon",
  },
  {
    id: "day-part-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "เย็น",
    romanized: "yen",
    meaning: "evening",
  },
  {
    id: "day-part-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "กลางคืน",
    romanized: "klaang-khuen",
    meaning: "night",
  },
];

export const timeAndCalendarContent: CategoryContent = {
  categoryId: "time-calendar",
  items: timeAndCalendar,
};

================
File: src/constants/content/travel.ts
================
import type { CategoryContent, PhraseContent } from "@/types/ContentTypes";

const travelPhrases: PhraseContent[] = [
  {
    id: "travel-1",
    type: "phrase",
    difficulty: "beginner",
    thai: "สนามบิน",
    romanized: "sa-naam-bin",
    meaning: "airport",
  },
  {
    id: "travel-2",
    type: "phrase",
    difficulty: "beginner",
    thai: "รถไฟ",
    romanized: "rot-fai",
    meaning: "train",
  },
  {
    id: "travel-3",
    type: "phrase",
    difficulty: "beginner",
    thai: "รถบัส",
    romanized: "rot-bát",
    meaning: "bus",
  },
  {
    id: "travel-4",
    type: "phrase",
    difficulty: "beginner",
    thai: "ท่าเรือ",
    romanized: "tháa-rua",
    meaning: "port/pier",
  },
  {
    id: "travel-5",
    type: "phrase",
    difficulty: "beginner",
    thai: "แผนที่",
    romanized: "phæ̂n-thîi",
    meaning: "map",
  },
  {
    id: "travel-6",
    type: "phrase",
    difficulty: "beginner",
    thai: "ตั๋ว",
    romanized: "dtua",
    meaning: "ticket",
  },
  {
    id: "travel-7",
    type: "phrase",
    difficulty: "beginner",
    thai: "โรงแรม",
    romanized: "rohng-rɛ̌ɛm",
    meaning: "hotel",
  },
  {
    id: "travel-8",
    type: "phrase",
    difficulty: "beginner",
    thai: "ร้านอาหาร",
    romanized: "rân-aa-hăan",
    meaning: "restaurant",
  },
  {
    id: "travel-9",
    type: "phrase",
    difficulty: "beginner",
    thai: "ทางด่วน",
    romanized: "tháaŋ-duan",
    meaning: "highway",
  },
  {
    id: "travel-10",
    type: "phrase",
    difficulty: "beginner",
    thai: "สถานที่ท่องเที่ยว",
    romanized: "sa-tháan-thîi-thoŋ-thîiao",
    meaning: "tourist attraction",
  },
];

export const travelContent: CategoryContent = {
  categoryId: "travel",
  items: travelPhrases,
};

================
File: src/constants/categories.ts
================
// src/constants/categories.ts
import { LearningCategory } from "@/types/LearningCategory";
import { isContentAvailable } from "./content/index";

// Group categories by difficulty
const BEGINNER_CATEGORIES: LearningCategory[] = [
  {
    id: "thai-script",
    title: "Thai Script",
    description:
      "Learn to read and write Thai consonants, vowels, and tone marks",
    icon: "GraduationCap",
    difficulty: "beginner",
  },
  {
    id: "common-phrases",
    title: "Common Phrases",
    description: "Essential everyday expressions and greetings",
    icon: "MessageSquare",
    difficulty: "beginner",
  },
  {
    id: "numbers",
    title: "Numbers & Counting",
    description: "Learn numbers, counting, and basic math terms",
    icon: "Hash",
    difficulty: "beginner",
  },
  {
    id: "food-drink",
    title: "Food & Drink",
    description: "Common dishes, ingredients, and ordering phrases",
    icon: "UtensilsCrossed",
    difficulty: "beginner",
  },
  {
    id: "time-calendar",
    title: "Time & Calendar",
    description: "Learn to tell time and express dates in Thai",
    icon: "Clock",
    difficulty: "beginner",
  },
  {
    id: "colors",
    title: "Colors",
    description: "Learn common colors and basic descriptive terms",
    icon: "Palette",
    difficulty: "beginner",
  },
  {
    id: "question-words",
    title: "Question Words",
    description: "Master the essential words for asking questions in Thai",
    icon: "HelpCircle",
    difficulty: "beginner",
  },
];

const INTERMEDIATE_CATEGORIES: LearningCategory[] = [
  {
    id: "thai-script-intermediate",
    title: "Intermediate Thai Script",
    description: "Learn complex consonants, vowel combinations, and tone rules",
    icon: "BookOpen",
    difficulty: "intermediate",
  },
  {
    id: "travel",
    title: "Travel & Transport",
    description: "Navigate Thailand with essential travel vocabulary",
    icon: "Plane",
    difficulty: "intermediate",
  },
  {
    id: "directions",
    title: "Directions",
    description: "Learn to give and receive directions in Thai",
    icon: "Map",
    difficulty: "intermediate",
  },
  {
    id: "family-relationships",
    title: "Family & Relationships",
    description: "Learn family member names and relationship terms",
    icon: "Users2",
    difficulty: "intermediate",
  },
];

const ADVANCED_CATEGORIES: LearningCategory[] = [
  {
    id: "thai-script-advanced",
    title: "Advanced Thai Script",
    description:
      "Master rare characters, Sanskrit influences, and special symbols",
    icon: "BookText",
    difficulty: "advanced",
  },
  {
    id: "pronouns",
    title: "Pronouns & Polite Particles",
    description: "Master Thai personal pronouns and polite particles",
    icon: "User",
    difficulty: "advanced",
  },
  {
    id: "classifiers",
    title: "Classifiers",
    description: "Learn Thai noun classifiers and their usage",
    icon: "LayoutGrid",
    difficulty: "advanced",
  },
];

const ALL_CATEGORIES = [
  ...BEGINNER_CATEGORIES,
  ...INTERMEDIATE_CATEGORIES,
  ...ADVANCED_CATEGORIES,
];

// Only export categories that have content
export const LEARNING_CATEGORIES = ALL_CATEGORIES.filter((category) =>
  isContentAvailable(category.id)
);

export { BEGINNER_CATEGORIES, INTERMEDIATE_CATEGORIES, ADVANCED_CATEGORIES };

================
File: src/constants/config.ts
================
export const HISTORY_LENGTH = 5;

export const GAME_CONFIG = {
  MIN_TIMER_DURATION: 5,
  MAX_TIMER_DURATION: 30,
  TIMER_STEP: 5,
  MIN_QUESTIONS: 5,
  MAX_QUESTIONS: 20,
  QUESTIONS_STEP: 5,
} as const;

================
File: src/constants/phrases.ts
================
import type { ThaiPhrase } from "@/types/ThaiPhrase";

export const THAI_PHRASES: ThaiPhrase[] = [
  {
    thai: "สวัสดี",
    romanized: "sawadee",
    meaning: "hello",
    category: "common-phrases",
  },
  {
    thai: "ขอบคุณ",
    romanized: "khop khun",
    meaning: "thank you",
    category: "common-phrases",
  },
  {
    thai: "ไม่เป็นไร",
    romanized: "mai pen rai",
    meaning: "no worries/you're welcome",
    category: "common-phrases",
  },
  {
    thai: "อร่อย",
    romanized: "aroi",
    meaning: "delicious",
    category: "food-drink",
  },
  {
    thai: "เท่าไหร่",
    romanized: "tao rai",
    meaning: "how much?",
    category: "travel",
  },
  {
    thai: "ไปไหน",
    romanized: "pai nai",
    meaning: "where are you going?",
    category: "travel",
  },
  {
    thai: "ร้อน",
    romanized: "ron",
    meaning: "hot (weather)",
    category: "common-phrases",
  },
  {
    thai: "หิว",
    romanized: "hiw",
    meaning: "hungry",
    category: "food-drink",
  },
  {
    thai: "เข้าใจ",
    romanized: "kao jai",
    meaning: "understand",
    category: "common-phrases",
  },
  {
    thai: "ไม่เข้าใจ",
    romanized: "mai kao jai",
    meaning: "don't understand",
    category: "common-phrases",
  },
  {
    thai: "เหนื่อย",
    romanized: "neuy",
    meaning: "tired",
    category: "common-phrases",
  },
  {
    thai: "อยากกิน",
    romanized: "yak gin",
    meaning: "want to eat",
    category: "food-drink",
  },
];

================
File: src/constants/settings.ts
================
import type { GameSettings } from "@/types/GameSettings";

export const DEFAULT_SETTINGS: GameSettings = {
  timerEnabled: true,
  timerDuration: 10,
  showRomanized: true,
  questionsPerRound: 10,
  autoSpeak: true,
};

================
File: src/context/AudioContext.tsx
================
"use client";

import {
  createContext,
  useContext,
  useState,
  useRef,
  useEffect,
  ReactNode,
} from "react";

interface AudioContextType {
  isSoundEnabled: boolean;
  toggleSound: () => void;
  playSound: (type: "success" | "error" | "complete" | "failure") => void;
}

// Create context with a default value
const GameAudioContext = createContext<AudioContextType>({
  isSoundEnabled: true,
  toggleSound: () => {},
  playSound: () => {},
});

interface AudioProviderProps {
  children: ReactNode;
}

export const AudioProvider = ({ children }: AudioProviderProps) => {
  const [isSoundEnabled, setIsSoundEnabled] = useState(true);
  const successAudioRef = useRef<HTMLAudioElement | null>(null);
  const errorAudioRef = useRef<HTMLAudioElement | null>(null);
  const completeAudioRef = useRef<HTMLAudioElement | null>(null);
  const failureAudioRef = useRef<HTMLAudioElement | null>(null);
  const [isAudioInitialized, setIsAudioInitialized] = useState(false);

  useEffect(() => {
    // Initialize and preload audio files
    successAudioRef.current = new Audio("/sounds/success.mp3");
    errorAudioRef.current = new Audio("/sounds/error.mp3");
    completeAudioRef.current = new Audio("/sounds/complete.mp3");
    failureAudioRef.current = new Audio("/sounds/failure.mp3");

    // Set up preloading
    const initializeAudio = async () => {
      try {
        // Preload all audio files
        const audioRefs = [
          successAudioRef,
          errorAudioRef,
          completeAudioRef,
          failureAudioRef,
        ];
        await Promise.all(
          audioRefs.map(async (ref) => {
            if (ref.current) {
              ref.current.preload = "auto";
              await ref.current.load();
            }
          })
        );
        setIsAudioInitialized(true);
      } catch (error) {
        console.error("Error preloading audio:", error);
      }
    };

    initializeAudio();

    // Cleanup function
    return () => {
      [
        successAudioRef,
        errorAudioRef,
        completeAudioRef,
        failureAudioRef,
      ].forEach((ref) => {
        if (ref.current) {
          ref.current.pause();
          ref.current = null;
        }
      });
    };
  }, []);

  const toggleSound = () => {
    setIsSoundEnabled((prev) => !prev);
  };

  const playSound = (type: "success" | "error" | "complete" | "failure") => {
    if (!isSoundEnabled || !isAudioInitialized) return;

    const audioRef = {
      success: successAudioRef,
      error: errorAudioRef,
      complete: completeAudioRef,
      failure: failureAudioRef,
    }[type].current;

    if (audioRef) {
      try {
        audioRef.currentTime = 0;
        const playPromise = audioRef.play();

        if (playPromise !== undefined) {
          playPromise.catch((error) => {
            console.error(`Error playing ${type} sound:`, error);
          });
        }
      } catch (error) {
        console.error(`Error playing ${type} sound:`, error);
      }
    }
  };

  return (
    <GameAudioContext.Provider
      value={{ isSoundEnabled, toggleSound, playSound }}
    >
      {children}
    </GameAudioContext.Provider>
  );
};

// Export the hook after the context and provider are defined
export const useAudio = () => useContext(GameAudioContext);

================
File: src/context/ThemeContext.tsx
================
"use client";

import { createContext, useContext, useEffect, useState } from "react";

type Theme = "light" | "dark";

type ThemeContextType = {
  theme: Theme;
  toggleTheme: () => void;
};

const ThemeContext = createContext<ThemeContextType>({
  theme: "light",
  toggleTheme: () => {},
});

export const useTheme = () => useContext(ThemeContext);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>("light");

  useEffect(() => {
    // Check for system preference or stored preference
    const storedTheme = localStorage.getItem("theme") as Theme;
    const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
      .matches
      ? "dark"
      : "light";

    setTheme(storedTheme || systemTheme);
  }, []);

  useEffect(() => {
    // Update document class when theme changes
    document.documentElement.classList.remove("light", "dark");
    document.documentElement.classList.add(theme);
    localStorage.setItem("theme", theme);
  }, [theme]);

  const toggleTheme = () => {
    setTheme((prevTheme) => (prevTheme === "light" ? "dark" : "light"));
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

================
File: src/hooks/useGameLogic.ts
================
"use client";

import { useState, useRef, useEffect, useCallback } from "react";
import type { LearningCategory } from "@/types/LearningCategory";
import type { FeedbackType } from "@/types/FeedbackType";
import type { GameSettings } from "@/types/GameSettings";
import type { ContentItem } from "@/types/ContentTypes";
import { CATEGORY_CONTENT } from "@/constants/content";
import { DEFAULT_SETTINGS } from "@/constants/settings";
import { useAudio } from "@/context/AudioContext";
import { WrongAnswer } from "@/types/WrongAnswerType";

interface UseGameLogicParams {
  settings: GameSettings;
  onGameOver: (score: number, wrongAnswers: WrongAnswer[]) => void;
  category: LearningCategory;
}

const useGameLogic = ({
  settings = DEFAULT_SETTINGS,
  onGameOver,
  category,
}: UseGameLogicParams) => {
  const [currentItem, setCurrentItem] = useState<ContentItem | null>(null);
  const [options, setOptions] = useState<ContentItem[]>([]);
  const [score, setScore] = useState(0);
  const [totalQuestions, setTotalQuestions] = useState(0);
  const [feedback, setFeedback] = useState<FeedbackType>(null);
  const [timeLeft, setTimeLeft] = useState(
    settings?.timerDuration ?? DEFAULT_SETTINGS.timerDuration
  );
  const [canProceed, setCanProceed] = useState(false);
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const categoryContentRef = useRef(CATEGORY_CONTENT[category.id]);
  const { playSound } = useAudio();
  const [wrongAnswers, setWrongAnswers] = useState<WrongAnswer[]>([]);

  const [questionSet, setQuestionSet] = useState<ContentItem[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const lastQuestionRef = useRef<string | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);

  const generateNewSet = useCallback(() => {
    const categoryContent = categoryContentRef.current;
    if (!categoryContent) return [];

    const allItems = [...categoryContent.items];

    // Shuffle all items to randomize order
    const shuffledItems = allItems.sort(() => Math.random() - 0.5);

    // Ensure no consecutive duplicates in the initial set
    for (let i = 1; i < shuffledItems.length; i++) {
      if (shuffledItems[i].id === shuffledItems[i - 1].id) {
        // Swap with a non-duplicate item
        const swapIndex = (i + 1) % shuffledItems.length;
        [shuffledItems[i], shuffledItems[swapIndex]] = [
          shuffledItems[swapIndex],
          shuffledItems[i],
        ];
      }
    }

    return shuffledItems;
  }, []);

  const setupQuestion = useCallback(
    (correct: ContentItem) => {
      const categoryContent = categoryContentRef.current;
      if (!categoryContent || !isInitialized) return; // Add initialization check

      const wrongOptions = categoryContent.items
        .filter((item) => item.id !== correct.id)
        .sort(() => Math.random() - 0.5)
        .slice(0, 3);

      const allOptions = [...wrongOptions, correct].sort(
        () => Math.random() - 0.5
      );

      setCurrentItem(correct);
      setOptions(allOptions);
      setFeedback(null);
      setCanProceed(false);

      if (settings.timerEnabled) {
        setTimeLeft(settings.timerDuration);
      }
    },
    [settings.timerDuration, settings.timerEnabled, isInitialized]
  );

  const generateQuestion = useCallback(() => {
    if (!isInitialized) return; // Add initialization check

    if (currentIndex >= questionSet.length || questionSet.length === 0) {
      const newSet = generateNewSet();
      setQuestionSet(newSet);
      setCurrentIndex(0);

      if (newSet.length > 0) {
        setupQuestion(newSet[0]);
        lastQuestionRef.current = newSet[0].id;
      }
    } else {
      const nextQuestion = questionSet[currentIndex];

      if (nextQuestion.id === lastQuestionRef.current) {
        const alternateIndex = (currentIndex + 1) % questionSet.length;
        setCurrentIndex(alternateIndex);
        setupQuestion(questionSet[alternateIndex]);
        lastQuestionRef.current = questionSet[alternateIndex].id;
      } else {
        setupQuestion(nextQuestion);
        lastQuestionRef.current = nextQuestion.id;
        setCurrentIndex((prev) => prev + 1);
      }
    }
  }, [currentIndex, questionSet, generateNewSet, setupQuestion, isInitialized]);

  const handleTimeUp = useCallback(() => {
    if (!currentItem || feedback || !settings.timerEnabled) return;

    playSound("error");

    setFeedback({
      correct: false,
      message: `Time's up! The answer was:`,
      answer: currentItem.meaning,
    });
    setCanProceed(true);
  }, [currentItem, feedback, settings.timerEnabled, playSound]);

  const handleAnswer = useCallback(
    (selected: ContentItem) => {
      if (feedback || !currentItem) return;

      if (timerRef.current) {
        clearTimeout(timerRef.current);
        timerRef.current = null;
      }

      const isCorrect = selected.id === currentItem.id;

      if (isCorrect) {
        setScore((prev) => prev + 1);
        playSound("success");
        setFeedback({
          correct: true,
          message: "",
        });
        setTimeout(() => {
          const newTotal = totalQuestions + 1;
          if (newTotal >= settings.questionsPerRound) {
            onGameOver(score + 1, wrongAnswers);
          } else {
            setTotalQuestions(newTotal);
            setCurrentIndex((prev) => prev + 1);
            generateQuestion();
          }
        }, 500);
      } else {
        playSound("error");
        setWrongAnswers((prev) => [
          ...prev,
          {
            question: currentItem,
            playerAnswer: selected,
          },
        ]);

        setFeedback({
          correct: false,
          message: `Incorrect. The answer was:`,
          answer: currentItem.meaning,
        });
        setCanProceed(true);
      }
    },
    [
      currentItem,
      feedback,
      totalQuestions,
      settings.questionsPerRound,
      onGameOver,
      score,
      generateQuestion,
      wrongAnswers,
      playSound,
    ]
  );

  const handleNextQuestion = useCallback(() => {
    const newTotal = totalQuestions + 1;
    if (newTotal >= settings.questionsPerRound) {
      onGameOver(score, wrongAnswers);
    } else {
      setTotalQuestions(newTotal);
      setCurrentIndex((prev) => prev + 1);
      generateQuestion();
    }
  }, [
    totalQuestions,
    settings.questionsPerRound,
    onGameOver,
    score,
    generateQuestion,
    wrongAnswers,
  ]);

  useEffect(() => {
    const initialSet = generateNewSet();

    // Set up initial question directly without using setupQuestion
    if (initialSet.length > 0) {
      const firstQuestion = initialSet[0];
      const categoryContent = categoryContentRef.current;

      if (categoryContent) {
        const wrongOptions = categoryContent.items
          .filter((item) => item.id !== firstQuestion.id)
          .sort(() => Math.random() - 0.5)
          .slice(0, 3);

        const allOptions = [...wrongOptions, firstQuestion].sort(
          () => Math.random() - 0.5
        );

        // Set all initial state synchronously
        setQuestionSet(initialSet);
        setCurrentIndex(0);
        setCurrentItem(firstQuestion);
        setOptions(allOptions);
        lastQuestionRef.current = firstQuestion.id;

        if (settings.timerEnabled) {
          setTimeLeft(settings.timerDuration);
        }
      }
    }

    // Mark as initialized only after everything is set up
    setIsInitialized(true);

    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, []);

  useEffect(() => {
    if (settings.timerEnabled && timeLeft > 0 && !feedback) {
      timerRef.current = setTimeout(() => {
        setTimeLeft((prev) => prev - 1);
      }, 1000);
    } else if (settings.timerEnabled && timeLeft === 0 && !feedback) {
      handleTimeUp();
    }

    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, [timeLeft, settings.timerEnabled, feedback, handleTimeUp]);

  return {
    currentItem,
    options,
    score,
    totalQuestions,
    feedback,
    timeLeft,
    canProceed,
    wrongAnswers,
    handleAnswer,
    handleNextQuestion,
  };
};

export default useGameLogic;

================
File: src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: src/types/ContentTypes.ts
================
import type { LearningCategoryId } from "./LearningCategory";

export interface BaseContent {
  id: string;
  difficulty: "beginner" | "intermediate" | "advanced";
  type: "phrase";
  thai: string;
  romanized: string;
  meaning: string;
  extra?: {
    wordThai?: string;
    wordMeaning?: string;
    class?: "low-class" | "mid-class" | "high-class";
    sound?: string;
  };
}

export type PhraseContent = BaseContent;

export type ContentItem = PhraseContent;

export interface CategoryContent {
  categoryId: LearningCategoryId;
  items: ContentItem[];
}

================
File: src/types/FeedbackType.ts
================
export type FeedbackType = {
  correct: boolean;
  message: string;
  answer?: string;
} | null;

================
File: src/types/GameSettings.ts
================
export type GameSettings = {
  timerEnabled: boolean;
  timerDuration: number;
  showRomanized: boolean;
  questionsPerRound: number;
  autoSpeak: boolean; // New setting
};

================
File: src/types/LearningCategory.ts
================
export type LearningCategoryId =
  | "thai-script"
  | "thai-script-intermediate"
  | "thai-script-advanced"
  | "common-phrases"
  | "numbers"
  | "tones"
  | "food-drink"
  | "travel"
  | "directions"
  | "pronouns"
  | "classifiers"
  | "time-calendar"
  | "family-relationships"
  | "colors"
  | "question-words";

export interface LearningCategory {
  id: LearningCategoryId;
  title: string;
  description: string;
  icon: string;
  difficulty: "beginner" | "intermediate" | "advanced";
}

================
File: src/types/ThaiPhrase.ts
================
import { LearningCategoryId } from "./LearningCategory";

export type ThaiPhrase = {
  thai: string;
  romanized: string;
  meaning: string;
  category: LearningCategoryId;
};

================
File: src/types/WrongAnswerType.ts
================
import { ContentItem } from "./ContentTypes";

export interface WrongAnswer {
  question: ContentItem;
  playerAnswer: ContentItem;
}

================
File: .eslintrc.json
================
{
  "extends": ["next/core-web-vitals", "next/typescript"]
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# env files (can opt-in for commiting if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}

================
File: next.config.ts
================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

================
File: package.json
================
{
  "name": "thai-language-game",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@radix-ui/react-collapsible": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "lucide-react": "^0.453.0",
    "next": "15.0.1",
    "react": "19.0.0-rc-69d4b800-20241021",
    "react-dom": "19.0.0-rc-69d4b800-20241021",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^8",
    "eslint-config-next": "15.0.1",
    "postcss": "^8",
    "tailwindcss": "^3.4.14",
    "typescript": "^5"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: README.md
================
# Thai Language Learning Game

A React-based interactive game for learning Thai phrases and script. Built with Next.js, TypeScript, and Tailwind CSS, utilizing the shadcn/ui component library.

## Features

- Multiple learning categories covering Thai script, common phrases, numbers, and more
- Three difficulty levels: beginner, intermediate, and advanced
- Interactive quiz format with multiple-choice questions
- Text-to-speech functionality for Thai pronunciation
- Customizable game settings:
  - Adjustable timer duration (5-30 seconds)
  - Optional romanized text display
  - Configurable number of questions per round (5-20)
  - Auto-play pronunciation setting
- Progress tracking with scores and review of incorrect answers
- Anti-repetition system to prevent frequent phrase repetition
- Clean, modern UI with animations and feedback
- Mobile-responsive design

## Tech Stack

- [Next.js 15](https://nextjs.org/) with App Router
- [TypeScript](https://www.typescriptlang.org/)
- [Tailwind CSS](https://tailwindcss.com/)
- [shadcn/ui](https://ui.shadcn.com/) component library
- [Lucide Icons](https://lucide.dev/)

## Getting Started

### Prerequisites

- Node.js 18.x or later
- npm or yarn

### Installation

1. Clone the repository:

```bash
git clone https://github.com/RichiePowell/thai-language-game.git
cd thai-language-game
```

2. Install dependencies:

```bash
npm install
# or
yarn install
```

3. Start the development server:

```bash
npm run dev
# or
yarn dev
```

4. Open [http://localhost:3000](http://localhost:3000) in your browser.

## Project Structure

```
src/
├── app/
│   ├── layout.tsx             # App layout component
│   └── page.tsx               # Main app page
├── components/
│   ├── game/                  # Game-related components
│   │   ├── CategorySelector.tsx
│   │   ├── GameHeader.tsx
│   │   ├── GameScreen.tsx
│   │   ├── MainMenu.tsx
│   │   ├── SettingsPanel.tsx
│   │   ├── ThaiCharacterDisplay.tsx
│   │   └── ThaiPhraseGame.tsx
│   └── ui/                    # UI components
├── constants/
│   ├── categories.ts          # Learning category data
│   ├── config.ts              # Game configuration
│   ├── content/               # Content for each category
│   │   ├── classifiers.ts
│   │   ├── commonPhrases.ts
│   │   ├── directions.ts
│   │   ├── foodAndDrink.ts
│   │   ├── index.ts
│   │   ├── numbers.ts
│   │   ├── pronouns.ts
│   │   ├── thaiScript.ts
│   │   ├── thaiScriptAdvanced.ts
│   │   ├── thaiScriptIntermediate.ts
│   │   └── travel.ts
│   ├── phrases.ts             # Thai phrases data (legacy)
│   └── settings.ts            # Default game settings
├── context/
│   └── AudioContext.tsx       # Audio context provider
├── hooks/
│   └── useGameLogic.ts        # Game logic hook
└── types/                     # Type definitions
    ├── ContentTypes.ts
    ├── FeedbackType.ts
    ├── GameSettings.ts
    ├── LearningCategory.ts
    ├── ThaiPhrase.ts
    └── WrongAnswerType.ts
```

## Game Features

### Learning Categories

- Thai Script (Beginner, Intermediate, Advanced)
- Common Phrases
- Numbers & Counting
- Food & Drink
- Travel & Transport
- Directions
- Pronouns & Polite Particles
- Classifiers

### Customization

- Timer settings (5-30 seconds)
- Number of questions per round (5-20)
- Romanized text toggle
- Auto-play pronunciation

### Anti-Repetition System

The game implements a history-based system to prevent phrases from repeating too frequently, ensuring a varied learning experience.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Thai phrase data curated for common, practical usage
- UI design inspired by modern language learning apps
- Built using the amazing shadcn/ui component library

## Future Enhancements

- [ ] Expanded content library with more phrases and categories
- [ ] Different game modes (writing practice, listening comprehension)
- [ ] Progress tracking across sessions
- [ ] Spaced repetition system for optimized learning
- [ ] User accounts and progress saving
- [ ] Leaderboards and achievements
- [ ] Mobile app version

================
File: tailwind.config.ts
================
// tailwind.config.ts
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  darkMode: "class",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [],
};

export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
